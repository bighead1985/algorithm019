##动态规划方程总结

###解决问题的步骤
- 思考状态（重点）
  - 状态的定义，先尝试「题目问什么，就把什么设置为状态」
  - 然后思考「状态如何转移」，如果「状态转移方程」不容易得到，尝试修改定义，目的依然是为了方便得到「状态转移方程」
- 思考状态转移方程（核心、难点）
- 思考初始化
- 思考输出
- 思考优化空间
  



####爬楼梯
```
dp[0] = 0;
dp[1] = 1;
dp[2] = 2;

dp[i] = dp[i-1] +dp[i-2];
```

####最长公共字符串
```
//s1[i] == s2[j],则表示在以当前结果就等于之前没进来字符串的结果+1.
dp[i][j] = dp[i-1][j-1] + 1;

//s1[i] != s2[j]则表示至少有一个不在（要么s1[i]不在，要么s2[j]不在，或者都不在）
dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);

```

####三角形的最小路径和
```
//j = 0;
dp[i][j] = dp[i-1][0] + tri[i][0]

//j = i;
dp[i][j] = dp[i-1][i-1] + tri[i][i]

//other
dp[i][j] = min(dp[i-1][j-1] + tri[i-1][j]) + tri[i][j]

//dp初始化,对于三角形的顶点来说，最小路径和就是自己本身
dp[0][0] = tri[0][0]


```

####最大子序列和
```
dp[i] = Math.max(dp[i- 1] + nums[i], nums[i])

//初始化条件
dp[0] = nums[0]

```

####爬楼梯
```
dp[0] = 0;
dp[1] = 1;
dp[2] = 2;

dp[i] = dp[i-1] +dp[i-2]
```

####打家劫舍
```
//边界条件
dp[0] = nums[0];
dp[1] = max(nums[0],nums[1]);

//other
dp[i] = max(dp[i-1]+nums[i],dp[i-1])

```


 ####不同路径 II
 ```
 
// 定义 dp 数组并初始化第 1 行和第 1 列
dp[i][0] = 1;
dp[0][j] = 1;
   
//(i,j)上无障碍物
dp[i][j] = dp[i−1,j]+dp[i,j−1]

//(i,j)上有障碍物
dp[i][j] = 0
​	
 
 //other
 dp[i] = max(dp[i-1]+nums[i],dp[i-1])
 
 ```
 
 ####最长上升子序列
 ```
//定义 dp[i]dp[i] 为考虑前 ii 个元素，以第 ii 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取

dp[i] = max(dp[j]) + 1,其中0 ≤ j < i且num[j] < num[i]
 
 ```
 
####最长回文字符串
```
dp[i][j] 表示s[i...j]是否是回文串

//j-i = 0
dp[i][j] = true;

//j-i = 1
dp[i][j] = s[i]==s[j];

//j-i > 1
dp[i][j] =  s[i]==s[j] && dp[i + 1][j - 1]);

```

###字符串匹配算法

