###动态规划方程总结

####爬楼梯
```
dp[0] = 0;
dp[1] = 1;
dp[2] = 2;

dp[i] = dp[i-1] +dp[i-2];
```

####最长公共字符串
```
//s1[i] == s2[j],则表示在以当前结果就等于之前没进来字符串的结果+1.
dp[i][j] = dp[i-1][j-1] + 1;

//s1[i] != s2[j]则表示至少有一个不在（要么s1[i]不在，要么s2[j]不在，或者都不在）
dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);

```

####三角形的最小路径和
```
//j = 0;
dp[i][j] = dp[i-1][0] + tri[i][0]

//j = i;
dp[i][j] = dp[i-1][i-1] + tri[i][i]

//other
dp[i][j] = min(dp[i-1][j-1] + tri[i-1][j]) + tri[i][j]

//dp初始化,对于三角形的顶点来说，最小路径和就是自己本身
dp[0][0] = tri[0][0]


```

####最大子序列和
```
dp[i] = Math.max(dp[i- 1] + nums[i], nums[i])

//初始化条件
dp[0] = nums[0]

```

####爬楼梯
```
dp[0] = 0;
dp[1] = 1;
dp[2] = 2;

dp[i] = dp[i-1] +dp[i-2]
```

####打家劫舍
```
//边界条件
dp[0] = nums[0];
dp[1] = max(nums[0],nums[1]);

//other
dp[i] = max(dp[i-1]+nums[i],dp[i-1])

```


 ####不同路径 II
 ```
 
// 定义 dp 数组并初始化第 1 行和第 1 列
dp[i][0] = 1;
dp[0][j] = 1;
   
//(i,j)上无障碍物
dp[i][j] = dp[i−1,j]+dp[i,j−1]

//(i,j)上有障碍物
dp[i][j] = 0
​	
 
 //other
 dp[i] = max(dp[i-1]+nums[i],dp[i-1])
 
 ```

###字符串匹配算法

