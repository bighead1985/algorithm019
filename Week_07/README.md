##学习笔记

###BFS/DFS代码模版
```
//DFS
const visited = {}
  function dfs(i) {
    if (满⾜特定条件）{
      // 返回结果 or 退出搜索空间
    }
    visited[i] = true // 将当前状态标为已搜索
    for (根据i能到达的下个状态j) {
      if (!visited[j]) { // 如果状态j没有被搜索过
        dfs(j)
      }
    }
  }
  
 //BFS
  const visited = {}
   function bfs() {
     let q = new Queue()
     q.push(初始状态)
     while(q.length) {
       let i = q.pop()
       if (visited[i]) continue
       if (i 是我们要找的⽬标) return 结果
       for (i的可抵达状态j) {
         if (j 合法) {
           q.push(j)
         }
       }
     }
   return 没找到
  }

```


###平衡树二叉树（AVL树）

####右右子树-> 左旋

```
A                     B                              
  \                  / \                  
   B        ->      A   C
    \
     C
```


####左左子树-> 右旋

```
    A                B                         
   /                / \                
  B        ->      C   A
 /
C
```


####左右子树-> 左右旋

```
    A                 C                              
   /                 / \                  
   B        ->      B   A 
    \
     C
```

####右左子树-> 右左旋

```
    A                 C                              
     \               / \                  
      B      ->     A   B 
     /
    C
```

###近似平衡树二叉树（红黑树）
确保左右子树的高度差小于二倍

- 每个节点要么是黑色，要么是红色
- 根节点是黑色
- 最下层的叶子节点（空节点）也是黑色
- 不能有相邻的2个红色节点
- 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点


###红黑树的比较
- AVL树提供更快的查询，因为它有很严格的平衡度，这样能保证树的高度在一个合理的范围之内
- 红黒树提供更快的插入和删除操作，因为它对比AVL树自平衡的旋转次数少了很多
- AVL树需要在每个节点存储高度因子等数据，而红黒树只需要一个bit来表示节点的颜色
- 红黑树应用在大多数语言（java,c++）的类库中，而AVL数一般应用在数据库产品中